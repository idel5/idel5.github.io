<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Demo Design Selector</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load p5.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      /* Custom styles for better visual appeal */
      body {
        font-family: "Inter", sans-serif;
        background-color: #f3f4f6; /* Light gray background */
      }
      .card-grid-container {
        max-height: calc(100vh - 4rem); /* Adjust based on header/footer */
        overflow-y: auto;
      }
      .card {
        transition: all 0.2s ease-in-out;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
      }
      .card.selected {
        border: 4px solid #4f46e5; /* Indigo ring for selection */
        box-shadow: 0 0 0 4px #818cf8;
      }
      /* Custom thumb color for the size slider */
      .slider-thumb-indigo::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #4f46e5;
        cursor: pointer;
      }
      .slider-thumb-indigo::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #4f46e5;
        cursor: pointer;
        border: none;
      }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b-2 pb-2">
      Demo Design Selector (Multi-Image Support)
    </h1>

    <div id="app-container" class="flex flex-col lg:flex-row gap-8">
      <!-- 1. Card Selection Grid (Left Side) -->
      <div
        class="lg:w-1/3 card-grid-container p-4 bg-white rounded-xl shadow-lg"
      >
        <h2 class="text-xl font-semibold mb-4 text-gray-700">
          Template Library
        </h2>
        <div id="card-grid" class="grid grid-cols-2 gap-4">
          <!-- Cards will be injected here by JavaScript -->
        </div>
      </div>

      <!-- 2. P5.js Design Area (Right Side) -->
      <div class="lg:w-2/3 p-4 bg-white rounded-xl shadow-lg flex flex-col">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Design Canvas</h2>
        <div
          id="p5-canvas-container"
          class="flex-grow flex items-center justify-center bg-gray-100 border border-gray-300 rounded-lg min-h-[400px]"
        >
          <!-- P5.js canvas will be inserted here -->
        </div>
        <p class="text-sm text-gray-500 mt-3 text-center mb-4">
          Click a template on the left to load it onto this canvas. **Click and Drag** elements directly on the canvas to reposition them!
        </p>

        <!-- Main Controls Container -->
        <div class="border-t border-gray-200 mt-4 pt-4 space-y-6">

          <!-- NEW: Active Element Status Panel -->
          <div class="p-4 bg-indigo-50 rounded-lg shadow-inner border border-indigo-200">
            <h3 class="text-lg font-bold mb-3 text-indigo-700">
              Active Element Status
            </h3>
            <p class="text-sm font-medium text-gray-700">
              Currently Selected: 
              <span id="active-element-status" class="font-extrabold text-lg text-indigo-900 ml-2">None</span>
            </p>
          </div>


          <!-- TEXT Controls Panel -->
          <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
            <h3 class="text-lg font-semibold mb-3 text-gray-700">
              Customize Text Overlay
            </h3>
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
              <!-- Text Input -->
              <div class="col-span-2">
                <label
                  for="text-input"
                  class="block text-sm font-medium text-gray-700"
                  >Text Content</label
                >
                <input
                  type="text"
                  id="text-input"
                  value="Your Custom Text"
                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border"
                />
              </div>

              <!-- Font Selector -->
              <div>
                <label
                  for="font-select"
                  class="block text-sm font-medium text-gray-700"
                  >Font Family</label
                >
                <select
                  id="font-select"
                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border bg-white"
                >
                  <option value="sans-serif">Sans-serif (Inter/Arial)</option>
                  <option value="serif">Serif (Times New Roman)</option>
                  <option value="monospace">Monospace (Courier)</option>
                  <option value="cursive">Cursive</option>
                </select>
              </div>

              <!-- Color Selector -->
              <div>
                <label
                  for="color-input"
                  class="block text-sm font-medium text-gray-700"
                  >Text Color</label
                >
                <input
                  type="color"
                  id="color-input"
                  value="#000000"
                  class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 border p-1 cursor-pointer"
                />
              </div>

              <!-- Size Slider -->
              <div>
                <label
                  for="font-size"
                  class="block text-sm font-medium text-gray-700"
                  >Size (<span id="size-value">48</span>px)</label
                >
                <input
                  type="range"
                  id="font-size"
                  min="16"
                  max="120"
                  value="48"
                  class="mt-1 w-full appearance-none bg-gray-200 rounded-lg h-2 slider-thumb-indigo"
                />
              </div>
            </div>
          </div>
          
          <!-- User Image Controls Panel (Now controls active image) -->
          <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
            <h3 class="text-lg font-semibold mb-3 text-gray-700">
              User Image Upload & Transform
            </h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
              <!-- Image Upload Input -->
              <div>
                <label for="image-upload" class="block text-sm font-medium text-gray-700">Upload New Image</label>
                <input type="file" id="image-upload" accept="image/png, image/jpeg, image/jpg" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
              </div>
              
              <!-- Image Scale Slider -->
              <div id="image-scale-control" class="opacity-50 pointer-events-none transition-opacity">
                  <label for="image-scale" class="block text-sm font-medium text-gray-700">Image Scale (<span id="scale-value">100</span>%)</label>
                  <input type="range" id="image-scale" min="10" max="300" value="100" class="mt-1 w-full appearance-none bg-gray-200 rounded-lg h-2 slider-thumb-indigo">
              </div>

              <!-- Reset Image Position Button -->
              <div id="reset-image-control" class="opacity-50 pointer-events-none transition-opacity">
                   <button id="reset-image-btn" class="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">Reset Position</button>
              </div>
            </div>
          </div>

        </div> <!-- End Main Controls Container -->
      </div>
    </div>

    <script>
      // --- 1. DATA AND STATE MANAGEMENT ---

      const cardsData = [
        // Placeholder image paths
        { id: 1, name: "Modern Floral", url: "https://placehold.co/800x600/b1c4e7/ffffff?text=Modern+Floral" },
        { id: 2, name: "Elegant Minimal", url: "https://placehold.co/800x600/f0f8ff/333333?text=Elegant+Minimal" },
        { id: 3, name: "Watercolor Abstract", url: "https://placehold.co/800x600/ffecdb/a0522d?text=Watercolor+Abstract" },
        { id: 4, name: "Simple Typography", url: "https://placehold.co/800x600/e6e6fa/000000?text=Simple+Typography" },
        { id: 5, name: "Geometric Pattern", url: "https://placehold.co/800x600/d3f8e2/1e90ff?text=Geometric+Pattern" },
        { id: 6, name: "Bright Celebration", url: "https://placehold.co/800x600/ffffa5/ff6347?text=Bright+Celebration" },
      ];

      let loadedImage = null; // Background template image
      let selectedCardId = 1;
      let p5Instance = null;
      
      // Array to store multiple user-uploaded image objects
      let userImages = []; 

      // Tracks the currently selected element
      let activeElement = {
          type: 'none', // 'text', 'image'
          index: -1,    // Index in the userImages array, or -1 for text/none
      };
      
      // State for custom text overlay
      let textState = {
        content: "Your Custom Text",
        font: "sans-serif",
        size: 48,
        color: "#000000",
        x: 0, // Initialized in p.setup
        y: 0, // Initialized in p.setup
        isDragging: false,
        offsetX: 0,
        offsetY: 0,
      };

      // --- 2. DOM RENDERING AND INTERACTION ---

      const cardGrid = document.getElementById("card-grid");
      const p5CanvasContainer = document.getElementById("p5-canvas-container");
      const activeElementStatus = document.getElementById("active-element-status");
      const imageScaleInput = document.getElementById('image-scale');
      const scaleValueSpan = document.getElementById('scale-value');
      const imageScaleControl = document.getElementById('image-scale-control');
      const resetImageControl = document.getElementById('reset-image-control');

      /**
       * Updates the UI controls based on the currently active element.
       */
      function updateUIForSelection() {
          let statusText = 'None';
          
          // 1. Update Status Text
          if (activeElement.type === 'text') {
              statusText = 'Text Overlay';
          } else if (activeElement.type === 'image' && activeElement.index >= 0) {
              statusText = `Image #${activeElement.index + 1}`;
          }
          activeElementStatus.textContent = statusText;

          // 2. Update Image Controls State (Disabled/Enabled)
          const isImageSelected = activeElement.type === 'image';

          imageScaleControl.classList.toggle('opacity-50', !isImageSelected);
          imageScaleControl.classList.toggle('pointer-events-none', !isImageSelected);
          resetImageControl.classList.toggle('opacity-50', !isImageSelected);
          resetImageControl.classList.toggle('pointer-events-none', !isImageSelected);

          if (isImageSelected) {
              const img = userImages[activeElement.index];
              const scalePercent = Math.round(img.currentScale * 100);
              imageScaleInput.value = scalePercent;
              scaleValueSpan.textContent = scalePercent;
          } else {
              // Reset visual controls when no image is selected
              imageScaleInput.value = 100;
              scaleValueSpan.textContent = 100;
          }

          if (p5Instance) p5Instance.redraw();
      }

      /**
       * Updates the selected card ID and loads the new background image.
       */
      function selectCard(id) {
        selectedCardId = id;
        renderCards();

        const selected = cardsData.find(card => card.id === id);
        const imageUrl = selected ? selected.url : cardsData[0].url;

        if (p5Instance) {
            loadedImage = p5Instance.loadImage(
                imageUrl,
                () => {
                    console.log("Template image loaded successfully: " + imageUrl);
                    p5Instance.redraw();
                },
                (err) => {
                    console.error("Failed to load template image: " + imageUrl, err);
                }
            );
        }
      }

      /**
       * Renders the cards from cardsData into the grid container.
       */
      function renderCards() {
        cardGrid.innerHTML = "";
        cardsData.forEach((card) => {
          const isSelected = card.id === selectedCardId;
          const cardElement = document.createElement("div");
          cardElement.id = `card-${card.id}`;
          cardElement.className = `card relative p-4 rounded-lg flex flex-col items-center justify-center text-center ${
            isSelected
              ? "selected ring-4 ring-indigo-500"
              : "bg-white hover:bg-gray-100"
          } transition`;
          cardElement.onclick = () => selectCard(card.id);

          let visualHtml = `
                    <img
                        src="${card.url}"
                        alt="${card.name} template"
                        class="w-16 h-16 object-cover rounded-md shadow-inner"
                        onerror="this.onerror=null; this.src='https://placehold.co/64x64/E0E0E0/333333?text=Template'"
                    >
                `;

          cardElement.innerHTML = `
                    <div class="mb-2 p-2">${visualHtml}</div>
                    <span class="text-sm font-medium text-gray-800">${card.name}</span>
                `;

          cardGrid.appendChild(cardElement);
        });
      }

      // Initial render of cards
      renderCards();
      updateUIForSelection();

      // --- Input Event Listeners ---
      
      // Text Controls
      document.getElementById("text-input").addEventListener("input", (e) => {
        textState.content = e.target.value;
        if (p5Instance) p5Instance.redraw();
      });

      document.getElementById("font-select").addEventListener("change", (e) => {
        textState.font = e.target.value;
        if (p5Instance) p5Instance.redraw();
      });

      document.getElementById("color-input").addEventListener("input", (e) => {
        textState.color = e.target.value;
        if (p5Instance) p5Instance.redraw();
      });

      const fontSizeInput = document.getElementById("font-size");
      const sizeValueSpan = document.getElementById("size-value");

      fontSizeInput.addEventListener("input", (e) => {
        textState.size = parseInt(e.target.value, 10);
        sizeValueSpan.textContent = textState.size;
        if (p5Instance) p5Instance.redraw();
      });
      
      // Image Upload Handler
      document.getElementById("image-upload").addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (file && p5Instance) {
              const reader = new FileReader();
              reader.onload = (readerEvent) => {
                  const dataURL = readerEvent.target.result;
                  p5Instance.loadImage(dataURL,
                      (img) => {
                          console.log("User image loaded successfully.");
                          
                          // 1. Create a new image state object
                          const newImageState = {
                              p5Img: img,
                              x: p5Instance.width / 4, // Initial position offset slightly
                              y: p5Instance.height / 4,
                              originalWidth: img.width,
                              originalHeight: img.height,
                              currentScale: 0.5, // Start smaller so it's manageable
                              isDragging: false,
                              offsetX: 0,
                              offsetY: 0,
                          };

                          // 2. Add to array
                          userImages.push(newImageState);
                          
                          // 3. Auto-select the new image
                          activeElement.type = 'image';
                          activeElement.index = userImages.length - 1;
                          
                          // 4. Update UI
                          updateUIForSelection();

                          p5Instance.redraw();
                      },
                      () => {
                          console.error("Failed to load user image.");
                      }
                  );
              };
              reader.readAsDataURL(file);
          }
      });

      // Image Scale Slider
      imageScaleInput.addEventListener('input', (e) => {
          const scalePercent = parseInt(e.target.value, 10);
          scaleValueSpan.textContent = scalePercent;
          
          if (activeElement.type === 'image' && activeElement.index >= 0) {
              userImages[activeElement.index].currentScale = scalePercent / 100;
              if (p5Instance) p5Instance.redraw();
          }
      });

      // Reset Image Position Button
      document.getElementById('reset-image-btn').addEventListener('click', () => {
          if (activeElement.type === 'image' && activeElement.index >= 0) {
              const img = userImages[activeElement.index];
              if (img.p5Img && p5Instance) {
                  // Recalculate position to center the current scaled image
                  const currentWidth = img.originalWidth * img.currentScale;
                  const currentHeight = img.originalHeight * img.currentScale;
                  img.x = p5Instance.width / 2 - currentWidth / 2;
                  img.y = p5Instance.height / 2 - currentHeight / 2;
                  p5Instance.redraw();
              }
          }
      });


      // --- 3. P5.JS SKETCH ---

      const sketch = (p) => {
        let canvas;
        let containerWidth, containerHeight;
        let textBounds = {}; 
        
        // p5.js preload function to load the initial image
        p.preload = () => {
          const initialCard = cardsData.find(c => c.id === selectedCardId);
          loadedImage = p.loadImage(
            initialCard ? initialCard.url : cardsData[0].url,
            () => { console.log("Initial template image loaded successfully."); },
            (err) => { console.error("Failed to load initial template image.", err); }
          );
        };

        p.setup = () => {
          containerWidth = p5CanvasContainer.offsetWidth;
          containerHeight = p5CanvasContainer.offsetHeight;

          canvas = p.createCanvas(containerWidth, containerHeight);
          canvas.parent("p5-canvas-container");

          // Initialize text position to center of canvas
          textState.x = p.width / 2;
          textState.y = p.height / 2;

          p.angleMode(p.DEGREES);
          p.noLoop();
        };

        p.windowResized = () => {
          containerWidth = p5CanvasContainer.offsetWidth;
          containerHeight = p5CanvasContainer.offsetHeight;
          p.resizeCanvas(containerWidth, containerHeight);

          // Update position controls after resize (simple approach)
          textState.x = p.constrain(textState.x, 0, p.width);
          textState.y = p.constrain(textState.y, 0, p.height);

          userImages.forEach(img => {
              // A more sophisticated constraint is needed, but for simplicity, just redraw
          });

          p.redraw();
        };

        // Helper function to check if mouse is over the text
        const isMouseOverText = () => {
          if (!textState.content) return false;
          // Check based on text position, size, and width
          return (
            p.mouseX > textBounds.x - textBounds.width / 2 &&
            p.mouseX < textBounds.x + textBounds.width / 2 &&
            p.mouseY > textBounds.y - textState.size &&
            p.mouseY < textBounds.y + textState.size / 2
          );
        };
        
        // Helper function to check if mouse is over a specific image object
        const isMouseOverImage = (img) => {
            if (!img.p5Img || img.originalWidth === 0) return false;
            const currentWidth = img.originalWidth * img.currentScale;
            const currentHeight = img.originalHeight * img.currentScale;
            
            return (
                p.mouseX > img.x &&
                p.mouseX < img.x + currentWidth &&
                p.mouseY > img.y &&
                p.mouseY < img.y + currentHeight
            );
        }

        p.mousePressed = () => {
            // 1. Check for image hit (in reverse order to hit the topmost image first)
            for (let i = userImages.length - 1; i >= 0; i--) {
                const img = userImages[i];
                if (isMouseOverImage(img)) {
                    img.isDragging = true;
                    img.offsetX = p.mouseX - img.x;
                    img.offsetY = p.mouseY - img.y;
                    
                    // Select the image
                    activeElement.type = 'image';
                    activeElement.index = i;
                    updateUIForSelection();
                    p.redraw();
                    return false; // Prevent background click logic
                }
            }

            // 2. Check for text hit
            if (isMouseOverText()) {
                textState.isDragging = true;
                textState.offsetX = p.mouseX - textState.x;
                textState.offsetY = p.mouseY - textState.y;
                
                // Select the text
                activeElement.type = 'text';
                activeElement.index = -1;
                updateUIForSelection();
                p.redraw();
                return false; // Prevent background click logic
            }
            
            // 3. Deselection Logic (Click on background)
            if (activeElement.type !== 'none') {
                activeElement.type = 'none';
                activeElement.index = -1;
                updateUIForSelection();
                p.redraw();
                return false;
            }
        };

        p.mouseDragged = () => {
            // Drag selected text
            if (textState.isDragging) {
                textState.x = p.mouseX - textState.offsetX;
                textState.y = p.mouseY - textState.offsetY;
                p.redraw();
            }
            
            // Drag selected image (if any)
            for (let i = 0; i < userImages.length; i++) {
                const img = userImages[i];
                if (img.isDragging) {
                    img.x = p.mouseX - img.offsetX;
                    img.y = p.mouseY - img.offsetY;
                    p.redraw();
                    break; // Only one element can be dragged at a time
                }
            }
        };

        p.mouseReleased = () => {
            textState.isDragging = false;
            userImages.forEach(img => img.isDragging = false);
            p.redraw();
        };

        p.draw = () => {
          // 1. Background: Clear the canvas
          p.background(240);
          p.noStroke();

          // 2. Draw the loaded template image
          if (loadedImage && loadedImage.width > 0) {
            let imgRatio = loadedImage.width / loadedImage.height;
            let canvasRatio = p.width / p.height;
            let drawWidth, drawHeight;
            let x, y;

            if (canvasRatio > imgRatio) {
              drawHeight = p.height;
              drawWidth = drawHeight * imgRatio;
            } else {
              drawWidth = p.width;
              drawHeight = drawWidth / imgRatio;
            }

            x = (p.width - drawWidth) / 2;
            y = (p.height - drawHeight) / 2;

            p.image(loadedImage, x, y, drawWidth, drawHeight);
          }
          
          // 3. Draw all user uploaded images (Drawn first among overlays)
          userImages.forEach((img, index) => {
              if (img.p5Img && img.originalWidth > 0) {
                  const currentWidth = img.originalWidth * img.currentScale;
                  const currentHeight = img.originalHeight * img.currentScale;

                  p.image(
                      img.p5Img,
                      img.x,
                      img.y,
                      currentWidth,
                      currentHeight
                  );
                  
                  // Draw selection boundary if this is the active element
                  if (activeElement.type === 'image' && activeElement.index === index) {
                      p.stroke(255, 165, 0); // Orange selection color
                      p.strokeWeight(3);
                      p.noFill();
                      p.rect(img.x, img.y, currentWidth, currentHeight);
                      p.noStroke();
                  }
              }
          });


          // 4. Draw the custom text overlay (Drawn last, on top)
          if (textState.content.length > 0) {
            p.fill(textState.color);
            p.textSize(textState.size);
            p.textAlign(p.CENTER, p.TOP);
            p.textFont(textState.font);
            p.text(textState.content, textState.x, textState.y);

            // Calculate and store text bounds
            textBounds.width = p.textWidth(textState.content);
            textBounds.x = textState.x;
            textBounds.y = textState.y;

            // Draw selection boundary if text is the active element
            if (activeElement.type === 'text') {
                p.stroke(255, 165, 0); // Orange selection color
                p.strokeWeight(3);
                p.noFill();
                
                // Approximate the bounding box based on textBounds and size
                const boxX = textBounds.x - textBounds.width / 2 - 5;
                const boxY = textBounds.y - textState.size - 5; 
                const boxW = textBounds.width + 10;
                const boxH = textState.size + 10 + textState.size / 2; 

                p.rect(boxX, boxY, boxW, boxH);
            }
          }
          p.noStroke(); // Reset stroke


          // 5. Cursor handling (Priority: Any drag > Any hover)
          let cursorType = p.ARROW;
          if (textState.isDragging || userImages.some(img => img.isDragging)) {
              cursorType = p.MOVE;
          } else if (isMouseOverText()) {
              cursorType = p.MOVE;
          } else {
              // Check for hover over any image
              for (let img of userImages) {
                  if (isMouseOverImage(img)) {
                      cursorType = p.MOVE;
                      break;
                  }
              }
          }
          p.cursor(cursorType);
        };
      };

      // Initialize the p5.js sketch when the window loads
      window.onload = () => {
        p5Instance = new p5(sketch);
      };
    </script>
  </body>
</html>
